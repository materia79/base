const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

// Modules need to be included seperately here per resource folder
// and generate a client index for them as well start then serverside if not disabled.
const folder_client_packages = path.join("client_packages", "/");

function checksumFile(hashName, path) {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash(hashName);
    const stream = fs.createReadStream(path);
    stream.on('error', err => reject(err));
    stream.on('data', chunk => hash.update(chunk));
    stream.on('end', () => resolve(hash.digest('hex')));
  });
}

mp.modules = {
  loaded: false,
  disabled: {
  },
  getDirTree: function (dir, recursive = false, dirList = [], fileList = []) {
    const files = fs.readdirSync(dir);

    for (const file of files) {
      const dirFile = path.join(dir, file);
      const dirent = fs.statSync(dirFile);

      if (dirent.isDirectory()) {
        dirList.push({ full: dirFile.toString(), name: file.toString() });
        if (recursive) mp.modules.getDirTree(dirFile, recursive, dirList, fileList);
      } else {
        fileList.push({ full: dirFile.toString(), name: file.toString() });
      }
    }
    return { dirs: dirList, files: fileList };
  },
  checkClientFiles: async () => {
    if (mp.events.delayInit) mp.events.delayInit("loading_modules");
    let restartNeeded = false;
    let clientModuleFolders = mp.modules.getDirTree("modules/").dirs;
    let moduleClientIndex = "// generated by `packages/modules/index.js`\n\n";
    let moduleClientGitIgnore = "# generated by `packages/modules/index.js`\n";

    for (let i = 0; i < clientModuleFolders.length; i++) {
      let directory = clientModuleFolders[i];
      let moduleName = directory.name;
      let moduleServerRoot = path.join(directory.full, "packages", "/");
      let serverModules = mp.modules.getDirTree(moduleServerRoot);

      for (let j = 0; j < serverModules.dirs.length; j++) {
        let serverModuleIndex = path.join(serverModules.dirs[j].full, "/", "index.js");

        if (!fs.existsSync(serverModuleIndex)) {
          console.log("[Modules] `" + serverModuleIndex + "` does not exist!");
        } else {
          if (!mp.modules.disabled[moduleName] && serverModules.dirs[j].name != "modules") {  // no disabled modules, no inception!
            console.log("[Modules] Starting package module `" + serverModules.dirs[j].name + "`...");
            require(path.join("..", "/", "..", "/", serverModuleIndex));
          } else console.log("[Modules] Skipping package module `" + serverModules.dirs[j].name + "`...");
        }
      }

      let moduleClientRoot = path.join(directory.full, folder_client_packages);
      let clientModules = mp.modules.getDirTree(moduleClientRoot, true);

      // check module directories
      for (let j = 0; j < clientModules.dirs.length; j++) {
        let moduleDir = clientModules.dirs[j];
        let targetDir = path.join(folder_client_packages, moduleDir.full.substring(moduleClientRoot.length));

        if (!fs.existsSync(targetDir)) {
          console.log("[Modules] Creating subdirectory " + targetDir);
          fs.mkdirSync(targetDir);
          restartNeeded = true;
        }
      };

      for (let k = 0; k < clientModules.files.length; k++) {
        let moduleFile = clientModules.files[k];
        let sourceFile = moduleFile.full;
        let targetFile = path.join(folder_client_packages, moduleFile.full.substring(moduleClientRoot.length));
        let targetFileArray = targetFile.split(path.join("/"));

        if (targetFileArray.length == 3 && targetFileArray[2].toLowerCase() == "index.js") {
          if (!mp.modules.disabled[targetFileArray[1]]) moduleClientIndex += "require(\"" + targetFileArray[1] + "/" + targetFileArray[2] + "\");\n";
          else console.log("[Modules] Skipping disabled module client `" + targetFileArray[1] + "`...");
          moduleClientGitIgnore += targetFileArray[1] + "\n";
        }
        if (targetFile != path.join(folder_client_packages, "index.js")) {
          let sourceFileHash = await checksumFile("SHA256", sourceFile);
          let sourceLastModified = fs.statSync(sourceFile);

          if (fs.existsSync(targetFile)) {
            let targetFileHash = await checksumFile("SHA256", targetFile);
            let targetLastModified = fs.statSync(targetFile);

            if (sourceFileHash != targetFileHash) {

              if (sourceLastModified.mtime.getTime() > targetLastModified.mtime.getTime()) {  // file in modules/ is newer
                console.log("[Modules] File `" + sourceFile + "` was changed, updating...");
                await fs.createReadStream(sourceFile).pipe(fs.createWriteStream(targetFile));
                restartNeeded = true;
              } else { // file in client_packages/ is newer
                console.log("[Modules] File `" + targetFile + "` was changed, updating...");
                await fs.createReadStream(targetFile).pipe(fs.createWriteStream(sourceFile));
              }
            }
          } else {
            console.log("[Module] Adding new file `" + targetFile + "`.");
            await fs.createReadStream(sourceFile).pipe(fs.createWriteStream(targetFile));
            restartNeeded = true;
          }
        }
      };
    };
    /*
    if (!fs.existsSync(path.join(folder_client_packages, "modules"))) {
      console.log("[Modules] Creating subdirectory `client_packages/modules`...");
      fs.mkdirSync(path.join(folder_client_packages, "modules"));
      restartNeeded = true;
    }
    */
    fs.writeFileSync(path.join(folder_client_packages, "modulesIndex.js"), moduleClientIndex);
    fs.writeFileSync(path.join(folder_client_packages, ".gitignore"), moduleClientGitIgnore);

    if (restartNeeded) {
      console.log("[Modules] CLIENT FILES CHANGED! PLEASE RESTART THE SERVER!");
      setTimeout(() => {
        process.exit();
      }, 3000);
    } else {
      if (mp.events.delayEvent) mp.events.finishedInit("loading_modules");
      console.log("[Modules] All client files okay!");
    }
  }
};
mp.modules.checkClientFiles();
